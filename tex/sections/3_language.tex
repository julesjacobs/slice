\section{The Slice Language and Type System}\label{sec:language}

The syntax of the \Slice{} language is shown in Figure~\ref{fig:grammar}.

\input{figures/grammar}

\noindent where $x$ ranges over variable names, $c$ ranges over floating point constants, $i$ ranges over integer constants, $k$ and $n$ are non-negative integers with $0 \leq k < n$, $h$ and $t$ are variables in list patterns, and $p_0, \ldots, p_n$ are probabilities that should sum to 1.

The uniform distribution $\uniform(e_1, e_2)$ represents a continuous random value uniformly distributed in the range $[e_1, e_2)$. Other continuous distributions are defined according to their standard statistical definitions. The implementation supports over 17 distributions including Gaussian, exponential, beta, gamma, Laplace, Cauchy, and others. The discrete distribution $\discrete(p_0, \ldots, p_{n})$ represents a random value that returns integer $i \in \{0, \ldots, n\}$ with probability $p_i$.

Beyond basic functional constructs (pairs, projections, lambda abstractions, and function application), the language includes:
\begin{itemize}
\item \textbf{Finite types}: Values of the form $\finconst{k}{n}$ represent finite type constants, where $k$ is a value in the finite type with $n$ elements.
\item \textbf{Boolean operations}: Logical operators $\logand$, $\logor$, and $\text{not}$ for boolean expressions.
\item \textbf{Fixed-point recursion}: The $\text{fix}$ construct enables recursive function definitions.
\item \textbf{Observations}: The $\text{observe}$ construct conditions the program on a boolean expression being true.
\item \textbf{Lists}: Constructed with $\text{nil}$ and $::$, and deconstructed with pattern matching.
\item \textbf{Mutable references}: Created with $\text{ref}$, dereferenced with $!$, and updated with $:=$.
\item \textbf{Sequencing}: The semicolon operator sequences expressions with side effects.
\end{itemize}

When we discretize continuous programs, we convert expressions involving continuous distributions into expressions with discrete distributions, and convert less-than comparisons into less-than-or-equal comparisons on the corresponding discrete intervals.

\subsection{Type System}\label{sec:type-system}

We introduce a type system that analyzes both the comparison points and concrete values of floating point expressions. We have the following types:
\begin{itemize}
    \item \bool: the expression is a boolean value (true or false)
    \item \intty: the expression is an integer value  
    \item $\fin{n}$: the expression is a finite type value in $\{0, 1, \ldots, n-1\}$
    \item \float$[B; V]$: the expression is a floating point value with comparison bounds $B$ and value set $V$
    \item $\tau_1 * \tau_2$: the expression is a pair with elements of type $\tau_1$ and $\tau_2$
    \item $\tau_1 \rightarrow \tau_2$: the expression is a function that takes an argument of type $\tau_1$ and returns a result of type $\tau_2$
    \item $\text{unit}$: the unit type with single value $()$
    \item $\text{list}(\tau)$: list of elements of type $\tau$
    \item $\text{ref}(\tau)$: mutable reference containing a value of type $\tau$
\end{itemize}

The float type \float$[B; V]$ uses a two-bag approach:
\begin{itemize}
    \item $B$ is the \emph{bound bag}, containing comparison bounds of the form $< c$ or $\leq c$
    \item $V$ is the \emph{value bag}, containing concrete float values that the expression can evaluate to
\end{itemize}

Both $B$ and $V$ can be either a finite set or $\top$ (representing an unknown/unbounded set). This forms a product lattice structure that we describe in detail below.

\subsubsection{Lattice Structure}

Each bag forms a join-semilattice with the following structure:
\begin{itemize}
    \item Elements: $\{\text{Finite}(S) \mid S \text{ is a finite set}\} \cup \{\top\}$
    \item Ordering: $\text{Finite}(S_1) \sqsubseteq \text{Finite}(S_2)$ if $S_1 \subseteq S_2$, and $\text{Finite}(S) \sqsubseteq \top$ for any $S$
    \item Join: $\text{Finite}(S_1) \sqcup \text{Finite}(S_2) = \text{Finite}(S_1 \cup S_2)$, and $x \sqcup \top = \top$ for any $x$
    \item Bottom: $\text{Finite}(\emptyset)$
    \item Top: $\top$
\end{itemize}

The float type forms a product lattice:
\begin{align}
\text{FloatLattice} &= \text{BoundLattice} \times \text{ValueLattice} \\
(B_1, V_1) \sqsubseteq (B_2, V_2) &\iff B_1 \sqsubseteq B_2 \land V_1 \sqsubseteq V_2 \\
(B_1, V_1) \sqcup (B_2, V_2) &= (B_1 \sqcup B_2, V_1 \sqcup V_2)
\end{align}

This product lattice is also a join-semilattice with:
\begin{itemize}
    \item Bottom element: $(\text{Finite}(\emptyset), \text{Finite}(\emptyset))$
    \item Top element: $(\top, \top)$
\end{itemize}

The lattice structure enables type inference to systematically collect and propagate information about both how values are used (bounds) and what values they can take (values).

\input{figures/lattice}

The typing rules are split into two parts: rules specific to float types and continuous distributions (Figure~\ref{fig:typing-float}), and rules for all other language constructs (Figure~\ref{fig:typing-general}).

\input{figures/typing-float}

\input{figures/typing-general}

