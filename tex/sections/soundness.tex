\section{Soundness Proof}\label{sec:soundness}

This section establishes the soundness of our discretization transformation. We proceed in three steps: first, we define a nondeterministic small-step semantics for the base language; second, we extend this to a probabilistic semantics that tracks distributions; and third, we prove that discretization preserves the probabilistic semantics.

\subsection{Nondeterministic Small-Step Semantics}

We begin by defining a small-step operational semantics for \Slice{} that treats probabilistic sampling nondeterministically. This semantics captures the possible values that expressions can take without tracking their probabilities.

\subsubsection{Values}

First, we define the set of values that expressions can evaluate to:
\begin{align*}
v ::= &\; c                                  & \text{float constant} \\
    | &\; \text{true} \mid \text{false}      & \text{boolean value} \\
    | &\; \finconst{k}{n}                    & \text{finite type value} \\
    | &\; i                                  & \text{integer value} \\
    | &\; ()                                 & \text{unit value} \\
    | &\; (v_1, v_2)                         & \text{pair value} \\
    | &\; \funkw \; x \; \rightarrow \; e    & \text{function closure} \\
    | &\; \text{nil}                         & \text{empty list} \\
    | &\; v_1 :: v_2                         & \text{list cons value} \\
    | &\; \ell                               & \text{location (for references)}
\end{align*}

\subsubsection{Evaluation Contexts}

We use evaluation contexts to specify the order of evaluation:
\begin{align*}
E ::= &\; [\cdot] \\
    | &\; \letkw \; x = E \; \inkw \; e \\
    | &\; E < e \mid v < E \\
    | &\; E \leq e \mid v \leq E \\
    | &\; E \finlt{n} e \mid v \finlt{n} E \\
    | &\; E \finleq{n} e \mid v \finleq{n} E \\
    | &\; E \logand e \mid v \logand E \\
    | &\; E \logor e \mid v \logor E \\
    | &\; \text{not}\; E \\
    | &\; \ifkw \; E \; \thenkw \; e_1 \; \elsekw \; e_2 \\
    | &\; (E, e) \mid (v, E) \\
    | &\; \fstkw \; E \mid \sndkw \; E \\
    | &\; E \; e \mid v \; E \\
    | &\; \text{observe}\; E \\
    | &\; E; e \\
    | &\; E :: e \mid v :: E \\
    | &\; \text{match}\; E \; \text{with}\; \ldots \\
    | &\; \text{ref}\; E \\
    | &\; !E \\
    | &\; E := e \mid v := E
\end{align*}

\subsubsection{Small-Step Relation}

We define the small-step relation $e \rightarrow \mathcal{P}(e')$ that maps an expression to a set of possible next expressions. For deterministic constructs, this set is a singleton; for probabilistic sampling, it contains all possible values in the distribution's support.

\paragraph{Basic Rules}

\begin{mathpar}
\inferrule[\textsc{Let}]
{\ }
{\letkw \; x = v \; \inkw \; e \rightarrow \{e[v/x]\}}

\inferrule[\textsc{IfTrue}]
{\ }
{\ifkw \; \text{true} \; \thenkw \; e_1 \; \elsekw \; e_2 \rightarrow \{e_1\}}

\inferrule[\textsc{IfFalse}]
{\ }
{\ifkw \; \text{false} \; \thenkw \; e_1 \; \elsekw \; e_2 \rightarrow \{e_2\}}

\inferrule[\textsc{Fst}]
{\ }
{\fstkw \; (v_1, v_2) \rightarrow \{v_1\}}

\inferrule[\textsc{Snd}]
{\ }
{\sndkw \; (v_1, v_2) \rightarrow \{v_2\}}

\inferrule[\textsc{App}]
{\ }
{(\funkw \; x \; \rightarrow \; e) \; v \rightarrow \{e[v/x]\}}
\end{mathpar}

\paragraph{Comparison Rules}

\begin{mathpar}
\inferrule[\textsc{LessTrue}]
{c_1 < c_2}
{c_1 < c_2 \rightarrow \{\text{true}\}}

\inferrule[\textsc{LessFalse}]
{c_1 \geq c_2}
{c_1 < c_2 \rightarrow \{\text{false}\}}

\inferrule[\textsc{LeqTrue}]
{i_1 \leq i_2}
{i_1 \leq i_2 \rightarrow \{\text{true}\}}

\inferrule[\textsc{LeqFalse}]
{i_1 > i_2}
{i_1 \leq i_2 \rightarrow \{\text{false}\}}
\end{mathpar}

\paragraph{Boolean Operations}

\begin{mathpar}
\inferrule[\textsc{AndTrue}]
{\ }
{\text{true} \logand e \rightarrow \{e\}}

\inferrule[\textsc{AndFalse}]
{\ }
{\text{false} \logand e \rightarrow \{\text{false}\}}

\inferrule[\textsc{OrTrue}]
{\ }
{\text{true} \logor e \rightarrow \{\text{true}\}}

\inferrule[\textsc{OrFalse}]
{\ }
{\text{false} \logor e \rightarrow \{e\}}

\inferrule[\textsc{NotTrue}]
{\ }
{\text{not}\; \text{true} \rightarrow \{\text{false}\}}

\inferrule[\textsc{NotFalse}]
{\ }
{\text{not}\; \text{false} \rightarrow \{\text{true}\}}
\end{mathpar}

\paragraph{List Operations}

\begin{mathpar}
\inferrule[\textsc{MatchNil}]
{\ }
{\text{match}\; \text{nil} \; \text{with}\; \text{nil} \rightarrow e_1 \mid h :: t \rightarrow e_2 \; \text{end} \rightarrow \{e_1\}}

\inferrule[\textsc{MatchCons}]
{\ }
{\text{match}\; v_1 :: v_2 \; \text{with}\; \text{nil} \rightarrow e_1 \mid h :: t \rightarrow e_2 \; \text{end} \rightarrow \{e_2[v_1/h, v_2/t]\}}
\end{mathpar}

\paragraph{Probabilistic Sampling (Nondeterministic)}

For continuous distributions, the small-step relation returns the set of all possible values in the distribution's support:

\begin{mathpar}
\inferrule[\textsc{Uniform}]
{v_1, v_2 \text{ are float values} \\ v_1 < v_2}
{\uniform(v_1, v_2) \rightarrow \{c \mid v_1 \leq c < v_2\}}

\inferrule[\textsc{Gaussian}]
{\mu, \sigma \text{ are float values} \\ \sigma > 0}
{\gaussian(\mu, \sigma) \rightarrow \{c \mid c \in \mathbb{R}\}}

\inferrule[\textsc{Exponential}]
{\lambda \text{ is a float value} \\ \lambda > 0}
{\exponential(\lambda) \rightarrow \{c \mid c \geq 0\}}

\inferrule[\textsc{Beta}]
{\alpha, \beta \text{ are float values} \\ \alpha > 0 \\ \beta > 0}
{\betafn(\alpha, \beta) \rightarrow \{c \mid 0 \leq c \leq 1\}}

\inferrule[\textsc{Discrete}]
{p_0, \ldots, p_n \text{ are probabilities}}
{\discrete(p_0, \ldots, p_n) \rightarrow \{0, 1, \ldots, n\}}
\end{mathpar}

\paragraph{Observations}

\begin{mathpar}
\inferrule[\textsc{ObserveTrue}]
{\ }
{\text{observe}\; \text{true} \rightarrow \{()\}}

\inferrule[\textsc{ObserveFalse}]
{\ }
{\text{observe}\; \text{false} \rightarrow \emptyset}
\end{mathpar}

Note that observing a false condition results in an empty set, representing program termination without producing a value.

\paragraph{References and State}

For references, we extend the semantics with a store $\sigma$ that maps locations to values. The relation becomes $\langle e, \sigma \rangle \rightarrow \mathcal{P}(\langle e', \sigma' \rangle)$:

\begin{mathpar}
\inferrule[\textsc{Ref}]
{\ell \text{ is a fresh location}}
{\langle \text{ref}\; v, \sigma \rangle \rightarrow \{\langle \ell, \sigma[\ell \mapsto v] \rangle\}}

\inferrule[\textsc{Deref}]
{\sigma(\ell) = v}
{\langle !\ell, \sigma \rangle \rightarrow \{\langle v, \sigma \rangle\}}

\inferrule[\textsc{Assign}]
{\ }
{\langle \ell := v, \sigma \rangle \rightarrow \{\langle (), \sigma[\ell \mapsto v] \rangle\}}
\end{mathpar}

\paragraph{Context Rule}

\begin{mathpar}
\inferrule[\textsc{Context}]
{e \rightarrow S}
{E[e] \rightarrow \{E[e'] \mid e' \in S\}}
\end{mathpar}

This nondeterministic semantics captures all possible execution paths of a probabilistic program without tracking the probability of each path. In the next subsection, we will extend this to a probabilistic semantics that properly tracks distributions.