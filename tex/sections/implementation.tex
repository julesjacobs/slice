\section{Implementation}\label{sec:implementation}

We have implemented \Slice{} as an OCaml-based compiler that transforms continuous probabilistic programs into discrete ones, which can then be analyzed using exact inference engines. The implementation consists of two main components: the \Slice{} compiler (\texttt{cdice}) and the Dice inference engine~\cite{Holtzen2020Dice}.

\subsection{Architecture Overview}

Figure~\ref{fig:architecture} shows the overall architecture of the \Slice{} system.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    component/.style={rectangle, draw, thick, minimum width=3cm, minimum height=1cm, align=center},
    data/.style={rectangle, draw, dashed, minimum width=2.5cm, minimum height=0.8cm, align=center},
    arrow/.style={->, thick},
    bigbox/.style={draw, thick, rounded corners, inner sep=0.3cm}
]
    % Input
    \node[data] (input) {\texttt{.cdice} file\\(continuous program)};
    
    % Slice compiler box
    \node[bigbox, below=0.5cm of input, minimum width=10cm, minimum height=7cm] (slicebox) {};
    \node[above] at (slicebox.north) {\textbf{\Slice{} Compiler (cdice)}};
    
    % Components inside Slice
    \node[component, below=1cm of input] (parser) {Parser\\(\texttt{parser.mly}, \texttt{lexer.mll})};
    \node[component, below of=parser] (typeinf) {Type Inference\\(\texttt{inference.ml})};
    \node[component, below of=typeinf] (disc) {Discretization\\(\texttt{discretization.ml})};
    \node[component, below of=disc] (todice) {Code Generation\\(\texttt{to\_dice.ml})};
    
    % Intermediate data structures
    \node[data, right=0.5cm of parser] (ast) {AST\\(\texttt{expr})};
    \node[data, right=0.5cm of typeinf] (tast) {Typed AST\\(\texttt{texpr})};
    \node[data, right=0.5cm of disc] (dast) {Discretized\\AST};
    
    % Bags module
    \node[component, left=0.5cm of typeinf, minimum width=2cm] (bags) {Bags\\(\texttt{bags.ml})};
    
    % Output from Slice
    \node[data, below=1cm of slicebox] (dice) {\texttt{.dice} file\\(discrete program)};
    
    % Dice engine
    \node[component, below=0.5cm of dice, minimum width=10cm] (diceengine) {Dice Inference Engine\\BDD compilation + Weighted Model Counting};
    
    % Final output
    \node[data, below=0.5cm of diceengine] (output) {Probability\\Distribution};
    
    % Arrows
    \draw[arrow] (input) -- (parser);
    \draw[arrow] (parser) -- (typeinf);
    \draw[arrow] (typeinf) -- (disc);
    \draw[arrow] (disc) -- (todice);
    \draw[arrow] (todice) -- (dice);
    \draw[arrow] (dice) -- (diceengine);
    \draw[arrow] (diceengine) -- (output);
    
    % Side arrows for data structures
    \draw[arrow, dashed] (parser) -- (ast);
    \draw[arrow, dashed] (typeinf) -- (tast);
    \draw[arrow, dashed] (disc) -- (dast);
    \draw[arrow, dashed] (bags) -- (typeinf);
\end{tikzpicture}
\caption{Architecture of the \Slice{} system. The \Slice{} compiler transforms continuous probabilistic programs into discrete ones through type-directed discretization. The resulting discrete program is then processed by the Dice inference engine to compute exact probability distributions.}
\label{fig:architecture}
\end{figure}

\subsection{Implementation Details}

\paragraph{Parser and Lexer} The frontend uses OCaml's Menhir parser generator to parse \texttt{.cdice} source files. The parser (\texttt{parser.mly}) defines the concrete syntax and produces an abstract syntax tree (AST) represented by the \texttt{expr} type. The lexer (\texttt{lexer.mll}) handles tokenization, including special tokens for finite type comparisons (e.g., \texttt{<\#n}).

\paragraph{Type Inference} The type inference module (\texttt{inference.ml}) implements the two-bag type system described in Section~\ref{sec:type-inference}. It uses a constraint-based approach with unification to infer types while collecting comparison bounds. The implementation features:
\begin{itemize}
    \item A union-find data structure for managing bags efficiently
    \item Listener patterns for propagating constraints between related expressions
    \item Subtyping rules that ensure proper information flow
\end{itemize}

\paragraph{Bags Module} The \texttt{bags.ml} module provides the lattice-based data structures for tracking bounds and values. It implements:
\begin{itemize}
    \item Generic bag operations (union, equality checking)
    \item Specialized \texttt{BoundBag} for comparison bounds ($<c$, $\leq c$)
    \item \texttt{FloatBag} for tracking concrete float values
    \item Efficient representation using either finite sets or $\top$
\end{itemize}

\paragraph{Discretization} The discretization module (\texttt{discretization.ml}) transforms typed continuous programs into discrete ones. For each continuous distribution, it:
\begin{enumerate}
    \item Extracts comparison thresholds from the bound bag
    \item Computes interval probabilities using distribution CDFs
    \item Generates equivalent discrete distributions
    \item Transforms comparisons to operate on interval indices
\end{enumerate}

\paragraph{Code Generation} The \texttt{to\_dice.ml} module generates Dice source code from the discretized AST. It handles the translation of \Slice{} constructs to their Dice equivalents, including special handling for finite types that become integers in Dice.

\paragraph{Runtime and Evaluation} The implementation includes:
\begin{itemize}
    \item An interpreter (\texttt{interp.ml}) for sampling-based execution
    \item Statistical testing to verify discretization correctness
    \item Support for multiple output formats (Dice, SPPL)
\end{itemize}

\subsection{Integration with Dice}

The Dice inference engine~\cite{Holtzen2020Dice} provides exact inference for discrete probabilistic programs using Binary Decision Diagrams (BDDs) and weighted model counting. Our discretized programs are designed to work seamlessly with Dice's capabilities:
\begin{itemize}
    \item Discrete distributions map directly to Dice's \texttt{discrete} construct
    \item Finite types become bounded integers
    \item Observations translate to Dice's conditioning primitives
\end{itemize}

The complete workflow is automated through the \texttt{run\_contdice.sh} script, which pipes the output of \Slice{} directly to Dice for inference.

\subsection{Engineering Considerations}

The implementation prioritizes correctness and clarity:
\begin{itemize}
    \item Extensive use of OCaml's type system for safety
    \item Modular design allowing independent testing of components
    \item Clear separation between syntax-directed and semantic phases
    \item Comprehensive test suite including adversarial examples
\end{itemize}

The \Slice{} compiler consists of approximately 3,400 lines of OCaml code (including the lexer, parser, type inference engine, discretization engine, and code generator), demonstrating that powerful program transformations can be implemented concisely.

The system is open-source and available at \url{https://github.com/[repository-url]}, along with benchmarks and documentation.


