\section{Implementation}\label{sec:implementation}

We have implemented \Slice{} as an OCaml-based compiler that transforms continuous probabilistic programs into discrete ones, which can then be analyzed using exact inference engines. The implementation consists of two main components: the \Slice{} compiler (\texttt{slice}) and the Dice inference engine~\cite{Holtzen2020Dice}.

\subsection{Architecture Overview}

Figure~\ref{fig:architecture} shows the overall architecture of the \Slice{} system.

\input{figures/architecture}

\subsection{Implementation Details}

\paragraph{Parser and Lexer} The frontend uses OCaml's Menhir parser generator to parse \texttt{.slice} source files. The parser (\texttt{parser.mly}) defines the concrete syntax and produces an abstract syntax tree (AST) represented by the \texttt{expr} type. The lexer (\texttt{lexer.mll}) handles tokenization, including special tokens for finite type comparisons (e.g., \texttt{<\#n}).

\paragraph{Type Inference} The type inference module (\texttt{inference.ml}) implements the two-bag type system described in Section~\ref{sec:type-inference}. It uses a constraint-based approach with unification to infer types while collecting comparison bounds. The implementation features:
\begin{itemize}
    \item A union-find data structure for managing bags efficiently
    \item Listener patterns for propagating constraints between related expressions
    \item Subtyping rules that ensure proper information flow
\end{itemize}

\paragraph{Bags Module} The \texttt{bags.ml} module provides the lattice-based data structures for tracking bounds and values. It implements:
\begin{itemize}
    \item Generic bag operations (union, equality checking)
    \item Specialized \texttt{BoundBag} for comparison bounds ($<c$, $\leq c$)
    \item \texttt{FloatBag} for tracking concrete float values
    \item Efficient representation using either finite sets or $\top$
\end{itemize}

\paragraph{Discretization} The discretization module (\texttt{discretization.ml}) transforms typed continuous programs into discrete ones. For each continuous distribution, it:
\begin{enumerate}
    \item Extracts comparison thresholds from the bound bag
    \item Computes interval probabilities using distribution CDFs
    \item Generates equivalent discrete distributions
    \item Transforms comparisons to operate on interval indices
\end{enumerate}

\paragraph{Code Generation} The \texttt{to\_dice.ml} module generates Dice source code from the discretized AST. It handles the translation of \Slice{} constructs to their Dice equivalents, including special handling for finite types that become integers in Dice.

\paragraph{Runtime and Evaluation} The implementation includes:
\begin{itemize}
    \item An interpreter (\texttt{interp.ml}) for sampling-based execution
    \item Statistical testing to verify discretization correctness
    \item Support for multiple output formats (Dice, SPPL)
\end{itemize}

\subsection{Integration with Dice}

The Dice inference engine~\cite{Holtzen2020Dice} provides exact inference for discrete probabilistic programs using Binary Decision Diagrams (BDDs) and weighted model counting. Our discretized programs are designed to work seamlessly with Dice's capabilities:
\begin{itemize}
    \item Discrete distributions map directly to Dice's \texttt{discrete} construct
    \item Finite types become bounded integers
    \item Observations translate to Dice's conditioning primitives
\end{itemize}

The complete workflow is automated through the \texttt{slice.py} script, which pipes the output of \Slice{} directly to Dice for inference.

\subsection{Engineering Considerations}

The implementation prioritizes correctness and clarity:
\begin{itemize}
    \item Extensive use of OCaml's type system for safety
    \item Modular design allowing independent testing of components
    \item Clear separation between syntax-directed and semantic phases
    \item Comprehensive test suite including adversarial examples
\end{itemize}

The \Slice{} compiler consists of approximately 3,400 lines of OCaml code (including the lexer, parser, type inference engine, discretization engine, and code generator), demonstrating that powerful program transformations can be implemented concisely.

The system is open-source and available at \url{https://github.com/[repository-url]}, along with benchmarks and documentation.


